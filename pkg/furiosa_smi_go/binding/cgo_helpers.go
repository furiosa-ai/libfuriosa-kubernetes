// WARNING: This file has automatically been generated on Wed, 22 May 2024 16:44:33 KST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package binding

/*
#include "furiosa-smi.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFuriosaSmiDeviceHandlesMemory allocates memory for type C.FuriosaSmiDeviceHandles in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceHandlesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceHandlesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceHandlesValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceHandles{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceHandles) Ref() *C.FuriosaSmiDeviceHandles {
	if x == nil {
		return nil
	}
	return x.ref1e2e4077
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceHandles) Free() {
	if x != nil && x.allocs1e2e4077 != nil {
		x.allocs1e2e4077.(*cgoAllocMap).Free()
		x.ref1e2e4077 = nil
	}
}

// NewFuriosaSmiDeviceHandlesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceHandlesRef(ref unsafe.Pointer) *FuriosaSmiDeviceHandles {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceHandles)
	obj.ref1e2e4077 = (*C.FuriosaSmiDeviceHandles)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceHandles) PassRef() (*C.FuriosaSmiDeviceHandles, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e2e4077 != nil {
		return x.ref1e2e4077, nil
	}
	mem1e2e4077 := allocFuriosaSmiDeviceHandlesMemory(1)
	ref1e2e4077 := (*C.FuriosaSmiDeviceHandles)(mem1e2e4077)
	allocs1e2e4077 := new(cgoAllocMap)
	allocs1e2e4077.Add(mem1e2e4077)

	var ccount_allocs *cgoAllocMap
	ref1e2e4077.count, ccount_allocs = (C.uint32_t)(x.Count), cgoAllocsUnknown
	allocs1e2e4077.Borrow(ccount_allocs)

	var cdevice_handles_allocs *cgoAllocMap
	ref1e2e4077.device_handles, cdevice_handles_allocs = *(*[64]C.FuriosaSmiDeviceHandle)(unsafe.Pointer(&x.DeviceHandles)), cgoAllocsUnknown
	allocs1e2e4077.Borrow(cdevice_handles_allocs)

	x.ref1e2e4077 = ref1e2e4077
	x.allocs1e2e4077 = allocs1e2e4077
	return ref1e2e4077, allocs1e2e4077

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceHandles) PassValue() (C.FuriosaSmiDeviceHandles, *cgoAllocMap) {
	if x.ref1e2e4077 != nil {
		return *x.ref1e2e4077, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceHandles) Deref() {
	if x.ref1e2e4077 == nil {
		return
	}
	x.Count = (uint32)(x.ref1e2e4077.count)
	x.DeviceHandles = *(*[64]FuriosaSmiDeviceHandle)(unsafe.Pointer(&x.ref1e2e4077.device_handles))
}

// allocFuriosaSmiFwVersionMemory allocates memory for type C.FuriosaSmiFwVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiFwVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiFwVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiFwVersionValue = unsafe.Sizeof([1]C.FuriosaSmiFwVersion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiFwVersion) Ref() *C.FuriosaSmiFwVersion {
	if x == nil {
		return nil
	}
	return x.ref3ba6be71
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiFwVersion) Free() {
	if x != nil && x.allocs3ba6be71 != nil {
		x.allocs3ba6be71.(*cgoAllocMap).Free()
		x.ref3ba6be71 = nil
	}
}

// NewFuriosaSmiFwVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiFwVersionRef(ref unsafe.Pointer) *FuriosaSmiFwVersion {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiFwVersion)
	obj.ref3ba6be71 = (*C.FuriosaSmiFwVersion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiFwVersion) PassRef() (*C.FuriosaSmiFwVersion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3ba6be71 != nil {
		return x.ref3ba6be71, nil
	}
	mem3ba6be71 := allocFuriosaSmiFwVersionMemory(1)
	ref3ba6be71 := (*C.FuriosaSmiFwVersion)(mem3ba6be71)
	allocs3ba6be71 := new(cgoAllocMap)
	allocs3ba6be71.Add(mem3ba6be71)

	var carch_allocs *cgoAllocMap
	ref3ba6be71.arch, carch_allocs = (C.FuriosaSmiArch)(x.Arch), cgoAllocsUnknown
	allocs3ba6be71.Borrow(carch_allocs)

	var cmajor_allocs *cgoAllocMap
	ref3ba6be71.major, cmajor_allocs = (C.uint32_t)(x.Major), cgoAllocsUnknown
	allocs3ba6be71.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	ref3ba6be71.minor, cminor_allocs = (C.uint32_t)(x.Minor), cgoAllocsUnknown
	allocs3ba6be71.Borrow(cminor_allocs)

	var cpatch_allocs *cgoAllocMap
	ref3ba6be71.patch, cpatch_allocs = (C.uint32_t)(x.Patch), cgoAllocsUnknown
	allocs3ba6be71.Borrow(cpatch_allocs)

	var cmetadata_allocs *cgoAllocMap
	ref3ba6be71.metadata, cmetadata_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Metadata)), cgoAllocsUnknown
	allocs3ba6be71.Borrow(cmetadata_allocs)

	x.ref3ba6be71 = ref3ba6be71
	x.allocs3ba6be71 = allocs3ba6be71
	return ref3ba6be71, allocs3ba6be71

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiFwVersion) PassValue() (C.FuriosaSmiFwVersion, *cgoAllocMap) {
	if x.ref3ba6be71 != nil {
		return *x.ref3ba6be71, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiFwVersion) Deref() {
	if x.ref3ba6be71 == nil {
		return
	}
	x.Arch = (FuriosaSmiArch)(x.ref3ba6be71.arch)
	x.Major = (uint32)(x.ref3ba6be71.major)
	x.Minor = (uint32)(x.ref3ba6be71.minor)
	x.Patch = (uint32)(x.ref3ba6be71.patch)
	x.Metadata = *(*[96]byte)(unsafe.Pointer(&x.ref3ba6be71.metadata))
}

// allocFuriosaSmiDriverVersionMemory allocates memory for type C.FuriosaSmiDriverVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDriverVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDriverVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDriverVersionValue = unsafe.Sizeof([1]C.FuriosaSmiDriverVersion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDriverVersion) Ref() *C.FuriosaSmiDriverVersion {
	if x == nil {
		return nil
	}
	return x.refd3ed194c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDriverVersion) Free() {
	if x != nil && x.allocsd3ed194c != nil {
		x.allocsd3ed194c.(*cgoAllocMap).Free()
		x.refd3ed194c = nil
	}
}

// NewFuriosaSmiDriverVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDriverVersionRef(ref unsafe.Pointer) *FuriosaSmiDriverVersion {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDriverVersion)
	obj.refd3ed194c = (*C.FuriosaSmiDriverVersion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDriverVersion) PassRef() (*C.FuriosaSmiDriverVersion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd3ed194c != nil {
		return x.refd3ed194c, nil
	}
	memd3ed194c := allocFuriosaSmiDriverVersionMemory(1)
	refd3ed194c := (*C.FuriosaSmiDriverVersion)(memd3ed194c)
	allocsd3ed194c := new(cgoAllocMap)
	allocsd3ed194c.Add(memd3ed194c)

	var carch_allocs *cgoAllocMap
	refd3ed194c.arch, carch_allocs = (C.FuriosaSmiArch)(x.Arch), cgoAllocsUnknown
	allocsd3ed194c.Borrow(carch_allocs)

	var cmajor_allocs *cgoAllocMap
	refd3ed194c.major, cmajor_allocs = (C.uint32_t)(x.Major), cgoAllocsUnknown
	allocsd3ed194c.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	refd3ed194c.minor, cminor_allocs = (C.uint32_t)(x.Minor), cgoAllocsUnknown
	allocsd3ed194c.Borrow(cminor_allocs)

	var cpatch_allocs *cgoAllocMap
	refd3ed194c.patch, cpatch_allocs = (C.uint32_t)(x.Patch), cgoAllocsUnknown
	allocsd3ed194c.Borrow(cpatch_allocs)

	var cmetadata_allocs *cgoAllocMap
	refd3ed194c.metadata, cmetadata_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Metadata)), cgoAllocsUnknown
	allocsd3ed194c.Borrow(cmetadata_allocs)

	x.refd3ed194c = refd3ed194c
	x.allocsd3ed194c = allocsd3ed194c
	return refd3ed194c, allocsd3ed194c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDriverVersion) PassValue() (C.FuriosaSmiDriverVersion, *cgoAllocMap) {
	if x.refd3ed194c != nil {
		return *x.refd3ed194c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDriverVersion) Deref() {
	if x.refd3ed194c == nil {
		return
	}
	x.Arch = (FuriosaSmiArch)(x.refd3ed194c.arch)
	x.Major = (uint32)(x.refd3ed194c.major)
	x.Minor = (uint32)(x.refd3ed194c.minor)
	x.Patch = (uint32)(x.refd3ed194c.patch)
	x.Metadata = *(*[96]byte)(unsafe.Pointer(&x.refd3ed194c.metadata))
}

// allocFuriosaSmiDeviceInfoMemory allocates memory for type C.FuriosaSmiDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceInfo) Ref() *C.FuriosaSmiDeviceInfo {
	if x == nil {
		return nil
	}
	return x.refde203aa5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceInfo) Free() {
	if x != nil && x.allocsde203aa5 != nil {
		x.allocsde203aa5.(*cgoAllocMap).Free()
		x.refde203aa5 = nil
	}
}

// NewFuriosaSmiDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceInfoRef(ref unsafe.Pointer) *FuriosaSmiDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceInfo)
	obj.refde203aa5 = (*C.FuriosaSmiDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceInfo) PassRef() (*C.FuriosaSmiDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde203aa5 != nil {
		return x.refde203aa5, nil
	}
	memde203aa5 := allocFuriosaSmiDeviceInfoMemory(1)
	refde203aa5 := (*C.FuriosaSmiDeviceInfo)(memde203aa5)
	allocsde203aa5 := new(cgoAllocMap)
	allocsde203aa5.Add(memde203aa5)

	var carch_allocs *cgoAllocMap
	refde203aa5.arch, carch_allocs = (C.FuriosaSmiArch)(x.Arch), cgoAllocsUnknown
	allocsde203aa5.Borrow(carch_allocs)

	var ccore_num_allocs *cgoAllocMap
	refde203aa5.core_num, ccore_num_allocs = (C.uint32_t)(x.CoreNum), cgoAllocsUnknown
	allocsde203aa5.Borrow(ccore_num_allocs)

	var cnuma_node_allocs *cgoAllocMap
	refde203aa5.numa_node, cnuma_node_allocs = (C.uint32_t)(x.NumaNode), cgoAllocsUnknown
	allocsde203aa5.Borrow(cnuma_node_allocs)

	var cname_allocs *cgoAllocMap
	refde203aa5.name, cname_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocsde203aa5.Borrow(cname_allocs)

	var cserial_allocs *cgoAllocMap
	refde203aa5.serial, cserial_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Serial)), cgoAllocsUnknown
	allocsde203aa5.Borrow(cserial_allocs)

	var cuuid_allocs *cgoAllocMap
	refde203aa5.uuid, cuuid_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Uuid)), cgoAllocsUnknown
	allocsde203aa5.Borrow(cuuid_allocs)

	var cbdf_allocs *cgoAllocMap
	refde203aa5.bdf, cbdf_allocs = *(*[96]C.char)(unsafe.Pointer(&x.Bdf)), cgoAllocsUnknown
	allocsde203aa5.Borrow(cbdf_allocs)

	var cmajor_allocs *cgoAllocMap
	refde203aa5.major, cmajor_allocs = (C.uint16_t)(x.Major), cgoAllocsUnknown
	allocsde203aa5.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	refde203aa5.minor, cminor_allocs = (C.uint16_t)(x.Minor), cgoAllocsUnknown
	allocsde203aa5.Borrow(cminor_allocs)

	var cfirmware_version_allocs *cgoAllocMap
	refde203aa5.firmware_version, cfirmware_version_allocs = x.FirmwareVersion.PassValue()
	allocsde203aa5.Borrow(cfirmware_version_allocs)

	var cdriver_version_allocs *cgoAllocMap
	refde203aa5.driver_version, cdriver_version_allocs = x.DriverVersion.PassValue()
	allocsde203aa5.Borrow(cdriver_version_allocs)

	x.refde203aa5 = refde203aa5
	x.allocsde203aa5 = allocsde203aa5
	return refde203aa5, allocsde203aa5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceInfo) PassValue() (C.FuriosaSmiDeviceInfo, *cgoAllocMap) {
	if x.refde203aa5 != nil {
		return *x.refde203aa5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceInfo) Deref() {
	if x.refde203aa5 == nil {
		return
	}
	x.Arch = (FuriosaSmiArch)(x.refde203aa5.arch)
	x.CoreNum = (uint32)(x.refde203aa5.core_num)
	x.NumaNode = (uint32)(x.refde203aa5.numa_node)
	x.Name = *(*[96]byte)(unsafe.Pointer(&x.refde203aa5.name))
	x.Serial = *(*[96]byte)(unsafe.Pointer(&x.refde203aa5.serial))
	x.Uuid = *(*[96]byte)(unsafe.Pointer(&x.refde203aa5.uuid))
	x.Bdf = *(*[96]byte)(unsafe.Pointer(&x.refde203aa5.bdf))
	x.Major = (uint16)(x.refde203aa5.major)
	x.Minor = (uint16)(x.refde203aa5.minor)
	x.FirmwareVersion = *NewFuriosaSmiFwVersionRef(unsafe.Pointer(&x.refde203aa5.firmware_version))
	x.DriverVersion = *NewFuriosaSmiDriverVersionRef(unsafe.Pointer(&x.refde203aa5.driver_version))
}

// allocFuriosaSmiDeviceFileMemory allocates memory for type C.FuriosaSmiDeviceFile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceFileValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceFileValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceFile{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceFile) Ref() *C.FuriosaSmiDeviceFile {
	if x == nil {
		return nil
	}
	return x.ref99363de2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceFile) Free() {
	if x != nil && x.allocs99363de2 != nil {
		x.allocs99363de2.(*cgoAllocMap).Free()
		x.ref99363de2 = nil
	}
}

// NewFuriosaSmiDeviceFileRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceFileRef(ref unsafe.Pointer) *FuriosaSmiDeviceFile {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceFile)
	obj.ref99363de2 = (*C.FuriosaSmiDeviceFile)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceFile) PassRef() (*C.FuriosaSmiDeviceFile, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref99363de2 != nil {
		return x.ref99363de2, nil
	}
	mem99363de2 := allocFuriosaSmiDeviceFileMemory(1)
	ref99363de2 := (*C.FuriosaSmiDeviceFile)(mem99363de2)
	allocs99363de2 := new(cgoAllocMap)
	allocs99363de2.Add(mem99363de2)

	var ccore_start_allocs *cgoAllocMap
	ref99363de2.core_start, ccore_start_allocs = (C.uint32_t)(x.CoreStart), cgoAllocsUnknown
	allocs99363de2.Borrow(ccore_start_allocs)

	var ccore_end_allocs *cgoAllocMap
	ref99363de2.core_end, ccore_end_allocs = (C.uint32_t)(x.CoreEnd), cgoAllocsUnknown
	allocs99363de2.Borrow(ccore_end_allocs)

	var cpath_allocs *cgoAllocMap
	ref99363de2.path, cpath_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Path)), cgoAllocsUnknown
	allocs99363de2.Borrow(cpath_allocs)

	x.ref99363de2 = ref99363de2
	x.allocs99363de2 = allocs99363de2
	return ref99363de2, allocs99363de2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceFile) PassValue() (C.FuriosaSmiDeviceFile, *cgoAllocMap) {
	if x.ref99363de2 != nil {
		return *x.ref99363de2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceFile) Deref() {
	if x.ref99363de2 == nil {
		return
	}
	x.CoreStart = (uint32)(x.ref99363de2.core_start)
	x.CoreEnd = (uint32)(x.ref99363de2.core_end)
	x.Path = *(*[256]byte)(unsafe.Pointer(&x.ref99363de2.path))
}

// allocFuriosaSmiDeviceFilesMemory allocates memory for type C.FuriosaSmiDeviceFiles in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceFilesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceFilesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceFilesValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceFiles{})

// allocA64FuriosaSmiDeviceFileMemory allocates memory for type [64]C.FuriosaSmiDeviceFile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA64FuriosaSmiDeviceFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA64FuriosaSmiDeviceFileValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA64FuriosaSmiDeviceFileValue = unsafe.Sizeof([1][64]C.FuriosaSmiDeviceFile{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA64FuriosaSmiDeviceFile transforms a sliced Go data structure into plain C format.
func unpackA64FuriosaSmiDeviceFile(x [64]FuriosaSmiDeviceFile) (unpacked [64]C.FuriosaSmiDeviceFile, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA64FuriosaSmiDeviceFileMemory(1)
	allocs.Add(mem0)
	v0 := (*[64]C.FuriosaSmiDeviceFile)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[64]C.FuriosaSmiDeviceFile)(mem0)
	return
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// packA64FuriosaSmiDeviceFile reads sliced Go data structure out from plain C format.
func packA64FuriosaSmiDeviceFile(v *[64]FuriosaSmiDeviceFile, ptr0 *[64]C.FuriosaSmiDeviceFile) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewFuriosaSmiDeviceFileRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceFiles) Ref() *C.FuriosaSmiDeviceFiles {
	if x == nil {
		return nil
	}
	return x.ref55937a62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceFiles) Free() {
	if x != nil && x.allocs55937a62 != nil {
		x.allocs55937a62.(*cgoAllocMap).Free()
		x.ref55937a62 = nil
	}
}

// NewFuriosaSmiDeviceFilesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceFilesRef(ref unsafe.Pointer) *FuriosaSmiDeviceFiles {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceFiles)
	obj.ref55937a62 = (*C.FuriosaSmiDeviceFiles)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceFiles) PassRef() (*C.FuriosaSmiDeviceFiles, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55937a62 != nil {
		return x.ref55937a62, nil
	}
	mem55937a62 := allocFuriosaSmiDeviceFilesMemory(1)
	ref55937a62 := (*C.FuriosaSmiDeviceFiles)(mem55937a62)
	allocs55937a62 := new(cgoAllocMap)
	allocs55937a62.Add(mem55937a62)

	var ccount_allocs *cgoAllocMap
	ref55937a62.count, ccount_allocs = (C.uint32_t)(x.Count), cgoAllocsUnknown
	allocs55937a62.Borrow(ccount_allocs)

	var cdevice_files_allocs *cgoAllocMap
	ref55937a62.device_files, cdevice_files_allocs = unpackA64FuriosaSmiDeviceFile(x.DeviceFiles)
	allocs55937a62.Borrow(cdevice_files_allocs)

	x.ref55937a62 = ref55937a62
	x.allocs55937a62 = allocs55937a62
	return ref55937a62, allocs55937a62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceFiles) PassValue() (C.FuriosaSmiDeviceFiles, *cgoAllocMap) {
	if x.ref55937a62 != nil {
		return *x.ref55937a62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceFiles) Deref() {
	if x.ref55937a62 == nil {
		return
	}
	x.Count = (uint32)(x.ref55937a62.count)
	packA64FuriosaSmiDeviceFile(&x.DeviceFiles, (*[64]C.FuriosaSmiDeviceFile)(unsafe.Pointer(&x.ref55937a62.device_files)))
}

// allocFuriosaSmiCoreStatusesMemory allocates memory for type C.FuriosaSmiCoreStatuses in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiCoreStatusesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiCoreStatusesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiCoreStatusesValue = unsafe.Sizeof([1]C.FuriosaSmiCoreStatuses{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiCoreStatuses) Ref() *C.FuriosaSmiCoreStatuses {
	if x == nil {
		return nil
	}
	return x.ref2e906eda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiCoreStatuses) Free() {
	if x != nil && x.allocs2e906eda != nil {
		x.allocs2e906eda.(*cgoAllocMap).Free()
		x.ref2e906eda = nil
	}
}

// NewFuriosaSmiCoreStatusesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiCoreStatusesRef(ref unsafe.Pointer) *FuriosaSmiCoreStatuses {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiCoreStatuses)
	obj.ref2e906eda = (*C.FuriosaSmiCoreStatuses)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiCoreStatuses) PassRef() (*C.FuriosaSmiCoreStatuses, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2e906eda != nil {
		return x.ref2e906eda, nil
	}
	mem2e906eda := allocFuriosaSmiCoreStatusesMemory(1)
	ref2e906eda := (*C.FuriosaSmiCoreStatuses)(mem2e906eda)
	allocs2e906eda := new(cgoAllocMap)
	allocs2e906eda.Add(mem2e906eda)

	var ccount_allocs *cgoAllocMap
	ref2e906eda.count, ccount_allocs = (C.uint32_t)(x.Count), cgoAllocsUnknown
	allocs2e906eda.Borrow(ccount_allocs)

	var ccore_status_allocs *cgoAllocMap
	ref2e906eda.core_status, ccore_status_allocs = *(*[128]C.FuriosaSmiCoreStatus)(unsafe.Pointer(&x.CoreStatus)), cgoAllocsUnknown
	allocs2e906eda.Borrow(ccore_status_allocs)

	x.ref2e906eda = ref2e906eda
	x.allocs2e906eda = allocs2e906eda
	return ref2e906eda, allocs2e906eda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiCoreStatuses) PassValue() (C.FuriosaSmiCoreStatuses, *cgoAllocMap) {
	if x.ref2e906eda != nil {
		return *x.ref2e906eda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiCoreStatuses) Deref() {
	if x.ref2e906eda == nil {
		return
	}
	x.Count = (uint32)(x.ref2e906eda.count)
	x.CoreStatus = *(*[128]FuriosaSmiCoreStatus)(unsafe.Pointer(&x.ref2e906eda.core_status))
}

// allocFuriosaSmiDeviceErrorInfoMemory allocates memory for type C.FuriosaSmiDeviceErrorInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceErrorInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceErrorInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceErrorInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceErrorInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceErrorInfo) Ref() *C.FuriosaSmiDeviceErrorInfo {
	if x == nil {
		return nil
	}
	return x.ref51d9cc38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceErrorInfo) Free() {
	if x != nil && x.allocs51d9cc38 != nil {
		x.allocs51d9cc38.(*cgoAllocMap).Free()
		x.ref51d9cc38 = nil
	}
}

// NewFuriosaSmiDeviceErrorInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceErrorInfoRef(ref unsafe.Pointer) *FuriosaSmiDeviceErrorInfo {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceErrorInfo)
	obj.ref51d9cc38 = (*C.FuriosaSmiDeviceErrorInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceErrorInfo) PassRef() (*C.FuriosaSmiDeviceErrorInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51d9cc38 != nil {
		return x.ref51d9cc38, nil
	}
	mem51d9cc38 := allocFuriosaSmiDeviceErrorInfoMemory(1)
	ref51d9cc38 := (*C.FuriosaSmiDeviceErrorInfo)(mem51d9cc38)
	allocs51d9cc38 := new(cgoAllocMap)
	allocs51d9cc38.Add(mem51d9cc38)

	var caxi_post_error_count_allocs *cgoAllocMap
	ref51d9cc38.axi_post_error_count, caxi_post_error_count_allocs = (C.uint32_t)(x.AxiPostErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(caxi_post_error_count_allocs)

	var caxi_fetch_error_count_allocs *cgoAllocMap
	ref51d9cc38.axi_fetch_error_count, caxi_fetch_error_count_allocs = (C.uint32_t)(x.AxiFetchErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(caxi_fetch_error_count_allocs)

	var caxi_discard_error_count_allocs *cgoAllocMap
	ref51d9cc38.axi_discard_error_count, caxi_discard_error_count_allocs = (C.uint32_t)(x.AxiDiscardErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(caxi_discard_error_count_allocs)

	var caxi_doorbell_error_count_allocs *cgoAllocMap
	ref51d9cc38.axi_doorbell_error_count, caxi_doorbell_error_count_allocs = (C.uint32_t)(x.AxiDoorbellErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(caxi_doorbell_error_count_allocs)

	var cpcie_post_error_count_allocs *cgoAllocMap
	ref51d9cc38.pcie_post_error_count, cpcie_post_error_count_allocs = (C.uint32_t)(x.PciePostErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(cpcie_post_error_count_allocs)

	var cpcie_fetch_error_count_allocs *cgoAllocMap
	ref51d9cc38.pcie_fetch_error_count, cpcie_fetch_error_count_allocs = (C.uint32_t)(x.PcieFetchErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(cpcie_fetch_error_count_allocs)

	var cpcie_discard_error_count_allocs *cgoAllocMap
	ref51d9cc38.pcie_discard_error_count, cpcie_discard_error_count_allocs = (C.uint32_t)(x.PcieDiscardErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(cpcie_discard_error_count_allocs)

	var cpcie_doorbell_error_count_allocs *cgoAllocMap
	ref51d9cc38.pcie_doorbell_error_count, cpcie_doorbell_error_count_allocs = (C.uint32_t)(x.PcieDoorbellErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(cpcie_doorbell_error_count_allocs)

	var cdevice_error_count_allocs *cgoAllocMap
	ref51d9cc38.device_error_count, cdevice_error_count_allocs = (C.uint32_t)(x.DeviceErrorCount), cgoAllocsUnknown
	allocs51d9cc38.Borrow(cdevice_error_count_allocs)

	x.ref51d9cc38 = ref51d9cc38
	x.allocs51d9cc38 = allocs51d9cc38
	return ref51d9cc38, allocs51d9cc38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceErrorInfo) PassValue() (C.FuriosaSmiDeviceErrorInfo, *cgoAllocMap) {
	if x.ref51d9cc38 != nil {
		return *x.ref51d9cc38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceErrorInfo) Deref() {
	if x.ref51d9cc38 == nil {
		return
	}
	x.AxiPostErrorCount = (uint32)(x.ref51d9cc38.axi_post_error_count)
	x.AxiFetchErrorCount = (uint32)(x.ref51d9cc38.axi_fetch_error_count)
	x.AxiDiscardErrorCount = (uint32)(x.ref51d9cc38.axi_discard_error_count)
	x.AxiDoorbellErrorCount = (uint32)(x.ref51d9cc38.axi_doorbell_error_count)
	x.PciePostErrorCount = (uint32)(x.ref51d9cc38.pcie_post_error_count)
	x.PcieFetchErrorCount = (uint32)(x.ref51d9cc38.pcie_fetch_error_count)
	x.PcieDiscardErrorCount = (uint32)(x.ref51d9cc38.pcie_discard_error_count)
	x.PcieDoorbellErrorCount = (uint32)(x.ref51d9cc38.pcie_doorbell_error_count)
	x.DeviceErrorCount = (uint32)(x.ref51d9cc38.device_error_count)
}

// allocFuriosaSmiDriverInfoMemory allocates memory for type C.FuriosaSmiDriverInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDriverInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDriverInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDriverInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDriverInfo{})

// allocA24FuriosaSmiDriverVersionMemory allocates memory for type [24]C.FuriosaSmiDriverVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA24FuriosaSmiDriverVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA24FuriosaSmiDriverVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA24FuriosaSmiDriverVersionValue = unsafe.Sizeof([1][24]C.FuriosaSmiDriverVersion{})

// unpackA24FuriosaSmiDriverVersion transforms a sliced Go data structure into plain C format.
func unpackA24FuriosaSmiDriverVersion(x [24]FuriosaSmiDriverVersion) (unpacked [24]C.FuriosaSmiDriverVersion, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA24FuriosaSmiDriverVersionMemory(1)
	allocs.Add(mem0)
	v0 := (*[24]C.FuriosaSmiDriverVersion)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[24]C.FuriosaSmiDriverVersion)(mem0)
	return
}

// packA24FuriosaSmiDriverVersion reads sliced Go data structure out from plain C format.
func packA24FuriosaSmiDriverVersion(v *[24]FuriosaSmiDriverVersion, ptr0 *[24]C.FuriosaSmiDriverVersion) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewFuriosaSmiDriverVersionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDriverInfo) Ref() *C.FuriosaSmiDriverInfo {
	if x == nil {
		return nil
	}
	return x.ref26157232
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDriverInfo) Free() {
	if x != nil && x.allocs26157232 != nil {
		x.allocs26157232.(*cgoAllocMap).Free()
		x.ref26157232 = nil
	}
}

// NewFuriosaSmiDriverInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDriverInfoRef(ref unsafe.Pointer) *FuriosaSmiDriverInfo {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDriverInfo)
	obj.ref26157232 = (*C.FuriosaSmiDriverInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDriverInfo) PassRef() (*C.FuriosaSmiDriverInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26157232 != nil {
		return x.ref26157232, nil
	}
	mem26157232 := allocFuriosaSmiDriverInfoMemory(1)
	ref26157232 := (*C.FuriosaSmiDriverInfo)(mem26157232)
	allocs26157232 := new(cgoAllocMap)
	allocs26157232.Add(mem26157232)

	var ccount_allocs *cgoAllocMap
	ref26157232.count, ccount_allocs = (C.uint32_t)(x.Count), cgoAllocsUnknown
	allocs26157232.Borrow(ccount_allocs)

	var cdriver_info_allocs *cgoAllocMap
	ref26157232.driver_info, cdriver_info_allocs = unpackA24FuriosaSmiDriverVersion(x.DriverInfo)
	allocs26157232.Borrow(cdriver_info_allocs)

	x.ref26157232 = ref26157232
	x.allocs26157232 = allocs26157232
	return ref26157232, allocs26157232

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDriverInfo) PassValue() (C.FuriosaSmiDriverInfo, *cgoAllocMap) {
	if x.ref26157232 != nil {
		return *x.ref26157232, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDriverInfo) Deref() {
	if x.ref26157232 == nil {
		return
	}
	x.Count = (uint32)(x.ref26157232.count)
	packA24FuriosaSmiDriverVersion(&x.DriverInfo, (*[24]C.FuriosaSmiDriverVersion)(unsafe.Pointer(&x.ref26157232.driver_info)))
}

// allocFuriosaSmiPeUtilizationMemory allocates memory for type C.FuriosaSmiPeUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiPeUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiPeUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiPeUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiPeUtilization{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiPeUtilization) Ref() *C.FuriosaSmiPeUtilization {
	if x == nil {
		return nil
	}
	return x.ref606fb886
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiPeUtilization) Free() {
	if x != nil && x.allocs606fb886 != nil {
		x.allocs606fb886.(*cgoAllocMap).Free()
		x.ref606fb886 = nil
	}
}

// NewFuriosaSmiPeUtilizationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiPeUtilizationRef(ref unsafe.Pointer) *FuriosaSmiPeUtilization {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiPeUtilization)
	obj.ref606fb886 = (*C.FuriosaSmiPeUtilization)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiPeUtilization) PassRef() (*C.FuriosaSmiPeUtilization, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref606fb886 != nil {
		return x.ref606fb886, nil
	}
	mem606fb886 := allocFuriosaSmiPeUtilizationMemory(1)
	ref606fb886 := (*C.FuriosaSmiPeUtilization)(mem606fb886)
	allocs606fb886 := new(cgoAllocMap)
	allocs606fb886.Add(mem606fb886)

	var ccore_count_allocs *cgoAllocMap
	ref606fb886.core_count, ccore_count_allocs = (C.uint32_t)(x.CoreCount), cgoAllocsUnknown
	allocs606fb886.Borrow(ccore_count_allocs)

	var ccores_allocs *cgoAllocMap
	ref606fb886.cores, ccores_allocs = *(*[64]C.uint32_t)(unsafe.Pointer(&x.Cores)), cgoAllocsUnknown
	allocs606fb886.Borrow(ccores_allocs)

	var ctime_window_mil_allocs *cgoAllocMap
	ref606fb886.time_window_mil, ctime_window_mil_allocs = (C.uint32_t)(x.TimeWindowMil), cgoAllocsUnknown
	allocs606fb886.Borrow(ctime_window_mil_allocs)

	var cpe_usage_percentage_allocs *cgoAllocMap
	ref606fb886.pe_usage_percentage, cpe_usage_percentage_allocs = (C.uint32_t)(x.PeUsagePercentage), cgoAllocsUnknown
	allocs606fb886.Borrow(cpe_usage_percentage_allocs)

	x.ref606fb886 = ref606fb886
	x.allocs606fb886 = allocs606fb886
	return ref606fb886, allocs606fb886

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiPeUtilization) PassValue() (C.FuriosaSmiPeUtilization, *cgoAllocMap) {
	if x.ref606fb886 != nil {
		return *x.ref606fb886, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiPeUtilization) Deref() {
	if x.ref606fb886 == nil {
		return
	}
	x.CoreCount = (uint32)(x.ref606fb886.core_count)
	x.Cores = *(*[64]uint32)(unsafe.Pointer(&x.ref606fb886.cores))
	x.TimeWindowMil = (uint32)(x.ref606fb886.time_window_mil)
	x.PeUsagePercentage = (uint32)(x.ref606fb886.pe_usage_percentage)
}

// allocFuriosaSmiMemoryUtilizationMemory allocates memory for type C.FuriosaSmiMemoryUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiMemoryUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiMemoryUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiMemoryUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiMemoryUtilization{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiMemoryUtilization) Ref() *C.FuriosaSmiMemoryUtilization {
	if x == nil {
		return nil
	}
	return x.ref7792c50a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiMemoryUtilization) Free() {
	if x != nil && x.allocs7792c50a != nil {
		x.allocs7792c50a.(*cgoAllocMap).Free()
		x.ref7792c50a = nil
	}
}

// NewFuriosaSmiMemoryUtilizationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiMemoryUtilizationRef(ref unsafe.Pointer) *FuriosaSmiMemoryUtilization {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiMemoryUtilization)
	obj.ref7792c50a = (*C.FuriosaSmiMemoryUtilization)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiMemoryUtilization) PassRef() (*C.FuriosaSmiMemoryUtilization, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7792c50a != nil {
		return x.ref7792c50a, nil
	}
	mem7792c50a := allocFuriosaSmiMemoryUtilizationMemory(1)
	ref7792c50a := (*C.FuriosaSmiMemoryUtilization)(mem7792c50a)
	allocs7792c50a := new(cgoAllocMap)
	allocs7792c50a.Add(mem7792c50a)

	var ctotal_bytes_allocs *cgoAllocMap
	ref7792c50a.total_bytes, ctotal_bytes_allocs = (C.uint64_t)(x.TotalBytes), cgoAllocsUnknown
	allocs7792c50a.Borrow(ctotal_bytes_allocs)

	var cin_use_bytes_allocs *cgoAllocMap
	ref7792c50a.in_use_bytes, cin_use_bytes_allocs = (C.uint64_t)(x.InUseBytes), cgoAllocsUnknown
	allocs7792c50a.Borrow(cin_use_bytes_allocs)

	x.ref7792c50a = ref7792c50a
	x.allocs7792c50a = allocs7792c50a
	return ref7792c50a, allocs7792c50a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiMemoryUtilization) PassValue() (C.FuriosaSmiMemoryUtilization, *cgoAllocMap) {
	if x.ref7792c50a != nil {
		return *x.ref7792c50a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiMemoryUtilization) Deref() {
	if x.ref7792c50a == nil {
		return
	}
	x.TotalBytes = (uint64)(x.ref7792c50a.total_bytes)
	x.InUseBytes = (uint64)(x.ref7792c50a.in_use_bytes)
}

// allocFuriosaSmiDeviceUtilizationMemory allocates memory for type C.FuriosaSmiDeviceUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceUtilization{})

// allocA64FuriosaSmiPeUtilizationMemory allocates memory for type [64]C.FuriosaSmiPeUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA64FuriosaSmiPeUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA64FuriosaSmiPeUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA64FuriosaSmiPeUtilizationValue = unsafe.Sizeof([1][64]C.FuriosaSmiPeUtilization{})

// unpackA64FuriosaSmiPeUtilization transforms a sliced Go data structure into plain C format.
func unpackA64FuriosaSmiPeUtilization(x [64]FuriosaSmiPeUtilization) (unpacked [64]C.FuriosaSmiPeUtilization, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA64FuriosaSmiPeUtilizationMemory(1)
	allocs.Add(mem0)
	v0 := (*[64]C.FuriosaSmiPeUtilization)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[64]C.FuriosaSmiPeUtilization)(mem0)
	return
}

// packA64FuriosaSmiPeUtilization reads sliced Go data structure out from plain C format.
func packA64FuriosaSmiPeUtilization(v *[64]FuriosaSmiPeUtilization, ptr0 *[64]C.FuriosaSmiPeUtilization) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewFuriosaSmiPeUtilizationRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceUtilization) Ref() *C.FuriosaSmiDeviceUtilization {
	if x == nil {
		return nil
	}
	return x.ref14f3ecf2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceUtilization) Free() {
	if x != nil && x.allocs14f3ecf2 != nil {
		x.allocs14f3ecf2.(*cgoAllocMap).Free()
		x.ref14f3ecf2 = nil
	}
}

// NewFuriosaSmiDeviceUtilizationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceUtilizationRef(ref unsafe.Pointer) *FuriosaSmiDeviceUtilization {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceUtilization)
	obj.ref14f3ecf2 = (*C.FuriosaSmiDeviceUtilization)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceUtilization) PassRef() (*C.FuriosaSmiDeviceUtilization, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref14f3ecf2 != nil {
		return x.ref14f3ecf2, nil
	}
	mem14f3ecf2 := allocFuriosaSmiDeviceUtilizationMemory(1)
	ref14f3ecf2 := (*C.FuriosaSmiDeviceUtilization)(mem14f3ecf2)
	allocs14f3ecf2 := new(cgoAllocMap)
	allocs14f3ecf2.Add(mem14f3ecf2)

	var cpe_count_allocs *cgoAllocMap
	ref14f3ecf2.pe_count, cpe_count_allocs = (C.uint32_t)(x.PeCount), cgoAllocsUnknown
	allocs14f3ecf2.Borrow(cpe_count_allocs)

	var cpe_allocs *cgoAllocMap
	ref14f3ecf2.pe, cpe_allocs = unpackA64FuriosaSmiPeUtilization(x.Pe)
	allocs14f3ecf2.Borrow(cpe_allocs)

	var cmemory_allocs *cgoAllocMap
	ref14f3ecf2.memory, cmemory_allocs = x.Memory.PassValue()
	allocs14f3ecf2.Borrow(cmemory_allocs)

	x.ref14f3ecf2 = ref14f3ecf2
	x.allocs14f3ecf2 = allocs14f3ecf2
	return ref14f3ecf2, allocs14f3ecf2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceUtilization) PassValue() (C.FuriosaSmiDeviceUtilization, *cgoAllocMap) {
	if x.ref14f3ecf2 != nil {
		return *x.ref14f3ecf2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceUtilization) Deref() {
	if x.ref14f3ecf2 == nil {
		return
	}
	x.PeCount = (uint32)(x.ref14f3ecf2.pe_count)
	packA64FuriosaSmiPeUtilization(&x.Pe, (*[64]C.FuriosaSmiPeUtilization)(unsafe.Pointer(&x.ref14f3ecf2.pe)))
	x.Memory = *NewFuriosaSmiMemoryUtilizationRef(unsafe.Pointer(&x.ref14f3ecf2.memory))
}

// allocFuriosaSmiDevicePowerConsumptionMemory allocates memory for type C.FuriosaSmiDevicePowerConsumption in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDevicePowerConsumptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDevicePowerConsumptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDevicePowerConsumptionValue = unsafe.Sizeof([1]C.FuriosaSmiDevicePowerConsumption{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDevicePowerConsumption) Ref() *C.FuriosaSmiDevicePowerConsumption {
	if x == nil {
		return nil
	}
	return x.ref880dd3b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDevicePowerConsumption) Free() {
	if x != nil && x.allocs880dd3b9 != nil {
		x.allocs880dd3b9.(*cgoAllocMap).Free()
		x.ref880dd3b9 = nil
	}
}

// NewFuriosaSmiDevicePowerConsumptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDevicePowerConsumptionRef(ref unsafe.Pointer) *FuriosaSmiDevicePowerConsumption {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDevicePowerConsumption)
	obj.ref880dd3b9 = (*C.FuriosaSmiDevicePowerConsumption)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDevicePowerConsumption) PassRef() (*C.FuriosaSmiDevicePowerConsumption, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref880dd3b9 != nil {
		return x.ref880dd3b9, nil
	}
	mem880dd3b9 := allocFuriosaSmiDevicePowerConsumptionMemory(1)
	ref880dd3b9 := (*C.FuriosaSmiDevicePowerConsumption)(mem880dd3b9)
	allocs880dd3b9 := new(cgoAllocMap)
	allocs880dd3b9.Add(mem880dd3b9)

	var crms_total_allocs *cgoAllocMap
	ref880dd3b9.rms_total, crms_total_allocs = (C.double)(x.RmsTotal), cgoAllocsUnknown
	allocs880dd3b9.Borrow(crms_total_allocs)

	x.ref880dd3b9 = ref880dd3b9
	x.allocs880dd3b9 = allocs880dd3b9
	return ref880dd3b9, allocs880dd3b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDevicePowerConsumption) PassValue() (C.FuriosaSmiDevicePowerConsumption, *cgoAllocMap) {
	if x.ref880dd3b9 != nil {
		return *x.ref880dd3b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDevicePowerConsumption) Deref() {
	if x.ref880dd3b9 == nil {
		return
	}
	x.RmsTotal = (float64)(x.ref880dd3b9.rms_total)
}

// allocFuriosaSmiDeviceTemperatureMemory allocates memory for type C.FuriosaSmiDeviceTemperature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceTemperatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceTemperatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceTemperatureValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceTemperature{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FuriosaSmiDeviceTemperature) Ref() *C.FuriosaSmiDeviceTemperature {
	if x == nil {
		return nil
	}
	return x.ref3d98ab15
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FuriosaSmiDeviceTemperature) Free() {
	if x != nil && x.allocs3d98ab15 != nil {
		x.allocs3d98ab15.(*cgoAllocMap).Free()
		x.ref3d98ab15 = nil
	}
}

// NewFuriosaSmiDeviceTemperatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFuriosaSmiDeviceTemperatureRef(ref unsafe.Pointer) *FuriosaSmiDeviceTemperature {
	if ref == nil {
		return nil
	}
	obj := new(FuriosaSmiDeviceTemperature)
	obj.ref3d98ab15 = (*C.FuriosaSmiDeviceTemperature)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FuriosaSmiDeviceTemperature) PassRef() (*C.FuriosaSmiDeviceTemperature, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d98ab15 != nil {
		return x.ref3d98ab15, nil
	}
	mem3d98ab15 := allocFuriosaSmiDeviceTemperatureMemory(1)
	ref3d98ab15 := (*C.FuriosaSmiDeviceTemperature)(mem3d98ab15)
	allocs3d98ab15 := new(cgoAllocMap)
	allocs3d98ab15.Add(mem3d98ab15)

	var csoc_peak_allocs *cgoAllocMap
	ref3d98ab15.soc_peak, csoc_peak_allocs = (C.int)(x.SocPeak), cgoAllocsUnknown
	allocs3d98ab15.Borrow(csoc_peak_allocs)

	var cambient_allocs *cgoAllocMap
	ref3d98ab15.ambient, cambient_allocs = (C.int)(x.Ambient), cgoAllocsUnknown
	allocs3d98ab15.Borrow(cambient_allocs)

	x.ref3d98ab15 = ref3d98ab15
	x.allocs3d98ab15 = allocs3d98ab15
	return ref3d98ab15, allocs3d98ab15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FuriosaSmiDeviceTemperature) PassValue() (C.FuriosaSmiDeviceTemperature, *cgoAllocMap) {
	if x.ref3d98ab15 != nil {
		return *x.ref3d98ab15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FuriosaSmiDeviceTemperature) Deref() {
	if x.ref3d98ab15 == nil {
		return
	}
	x.SocPeak = (int32)(x.ref3d98ab15.soc_peak)
	x.Ambient = (int32)(x.ref3d98ab15.ambient)
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}
